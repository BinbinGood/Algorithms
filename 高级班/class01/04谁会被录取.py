# 某公司招聘，有n个人入围，HR在黑板上依次写下m个正整数A1、A2、……、Am，然后让这n个人围成一个
# 圈，并按照顺时针顺序为他们编号0、1、2、……、n-1。录取规则是：
# 第一轮从0号的人开始，取用黑板上的第1个数字，也就是A1
# 黑板上的数字按次序循环取用，即如果某轮用了第m个，则下一轮需要用第1个；如果某轮用到第k个，则
# 下轮需要用第k+1个（k<m）
# 每一轮按照黑板上的次序取用到一个数字Ax，淘汰掉从当前轮到的人开始按照顺时针顺序数到的第Ax个
# 人，下一轮开始时轮到的人即为被淘汰掉的人的顺时针顺序下一个人
# 被淘汰的人直接回家，所以不会被后续轮次计数时数到
# 经过n-1轮后，剩下的最后1人被录取
# 所以最后被录取的人的编号与（n，m，A1，A2，……，Am）相关。
# 输入描述：
# 第一行是一个正整数N，表示有N组参数
# 从第二行开始，每行有若干个正整数，依次存放n、m、A1、……、Am，一共有N行，也就是上面的N组参
# 数。
# 输出描述：
# 输出有N行，每行对应相应的那组参数确定的录取之人的编号示例1:
# 输入
# 1
# 4 2 3 1
# 输出
# 1

# 题目的算法原型为约瑟夫环问题
# 给定人数，和要杀的人的数字为m，当某个人报号到m就杀死这个人，然后从杀死的人下一个人重新开始报号.报号从1开始
def getlive(i, m):
    if i == 1:
        return 1
    return (getlive(i - 1, m) + m - 1) % i + 1


# 这道题目在原始问题的基础上，将杀人的数字M规定为可变的
def live(n, arr1):
    return no(n, arr1, 0)


# 还剩i个人，当前取用的数字为arr1[index]
# 返回最终活下的人，在原始人群中的编号
def no(i, arr1, index):
    if i == 1:
        return 1
    return (no(i - 1, arr1, nextindex(len(arr1), index)) + arr1[index] - 1) % i + 1


# 如果数组的长度为size,当前的下标为index
# 返回循环模型下，下一个index是多少
def nextindex(size, index):
    return 0 if index == size - 1 else index + 1


print(live(4, [3, 1]))  # 我们这个算法最终返回的编号是从1开始的
